<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мультифункциональное обнаружение</title>
    <script src="https://unpkg.com/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Изменено на flex-start */
            height: 100vh;
            background-color: #f0f0f0;
            font-family: sans-serif;
            overflow-x: hidden; /* Добавлено для предотвращения горизонтальной полосы прокрутки */
        }
        #videoElement {
            position: fixed; /* Фиксированное позиционирование */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Видео занимает всю область, сохраняя пропорции */
            z-index: -1; /* Помещаем видео на задний план */
        }
        #canvasElement {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Canvas не перехватывает события мыши */
        }
        #controls {
            position: relative; /* Позиционирование относительно обычного потока */
            z-index: 10; /* Убедитесь, что элементы управления находятся поверх видео */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px; /* Добавлен верхний отступ, чтобы не перекрывалось видео */
        }
        .button {
            padding: 10px 15px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #367c39;
        }
        .button:active {
            background-color: #2b5e2e;
        }
        #gestureInfo {
            position: fixed; /* Фиксированное позиционирование */
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            z-index: 10;
        }
        # опасные {
             color: red;
        }
        #еда {
            color: green;
        }
    </style>
</head>
<body>
    <video id="videoElement" autoplay muted></video>
    <canvas id="canvasElement"></canvas>
    <div id="controls">
        <button id="fullscreenButton" class="button">Полноэкранный режим</button>
        <button id="cameraSwitchButton" class="button">Сменить камеру</button>
    </div>
    <div id="gestureInfo">Жесты: OK - очистить, Кулак x2 + Указательный палец - рисовать</div>
    <script>
        // Получаем элементы video и canvas
        const videoElement = document.getElementById('videoElement');
        const canvasElement = document.getElementById('canvasElement');
        const canvasContext = canvasElement.getContext('2d');
        const fullscreenButton = document.getElementById('fullscreenButton');
        const cameraSwitchButton = document.getElementById('cameraSwitchButton');
        const gestureInfoElement = document.getElementById('gestureInfo');

        // Глобальные переменные
        let рукиМодель;
        let cocoSsdModel;
        let лицоМодель;
        let камераId = 'user'; // 'user' для передней, 'environment' для задней
        let isDrawing = false;
        let предыдущаяX = 0;
        let предыдущаяY = 0;
        let detectedObjects = []; // Массив для хранения обнаруженных объектов
        let палецВерх = [false, false, false, false, false]; // Массив для отслеживания состояния пальцев
        let кулак = false;
        let кулакПопытки = 0;

        // Загрузка моделей TensorFlow.js и MediaPipe
        async function загрузитьМодели() {
            await tf.ready();
            рукиМодель = await hands.load();
            cocoSsdModel = await cocoSsd.load();
            await faceapi.nets.tinyFaceDetector.loadFromUri('/models');
            await faceapi.nets.ageGenderNet.loadFromUri('/models');
            await faceapi.nets.faceExpressionNet.loadFromUri('/models');
            console.log('Модели загружены');
            начатьПотокКамеры();
        }

        // Функция для запуска потока камеры
        async function начатьПотокКамеры() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: камераId
                    },
                    audio: false
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    // Устанавливаем размеры canvas равными размерам видео
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    обнаружитьОбъекты(); // Запускаем обнаружение объектов
                    обнаружитьРуки();    // Запускаем обнаружение рук
                    обнаружитьЛица();
                };
            } catch (err) {
                console.error('Ошибка при получении доступа к камере:', err);
                alert('Не удалось получить доступ к камере. Пожалуйста, убедитесь, что камера разрешена и подключена.');
            }
        }

        // Функция для переключения камеры
        async function переключитьКамеру() {
            камераId = камераId === 'user' ? 'environment' : 'user';
            const текущийПоток = videoElement.srcObject;
            if (текущийПоток) {
                текущийПоток.getTracks().forEach(track => track.stop());
            }
            начатьПотокКамеры();
        }
        cameraSwitchButton.addEventListener('click', переключитьКамеру);

        // Функция для полноэкранного режима
        function включитьПолноэкранныйРежим() {
            if (videoElement.requestFullscreen) {
                videoElement.requestFullscreen();
            } else if (videoElement.mozRequestFullScreen) {
                videoElement.mozRequestFullScreen();
            } else if (videoElement.webkitRequestFullscreen) {
                videoElement.webkitRequestFullscreen();
            } else if (videoElement.msRequestFullscreen) {
                videoElement.msRequestFullscreen();
            }
        }
        fullscreenButton.addEventListener('click', включитьПолноэкранныйРежим);

        // Функция для обнаружения объектов
        async function обнаружитьОбъекты() {
            if (!cocoSsdModel) {
                console.warn('Модель COCO SSD еще не загружена');
                setTimeout(обнаружитьОбъекты, 100); // Повторная попытка через 100 мс
                return;
            }

            try {
                const predictions = await cocoSsdModel.detect(videoElement);
                detectedObjects = predictions; // Сохраняем обнаруженные объекты
            } catch (error) {
                console.error("Ошибка во время обнаружения объектов:", error);
            }
            requestAnimationFrame(обнаружитьОбъекты); // Продолжаем обнаружение в следующем кадре
        }

        // Функция для обнаружения рук
        async function обнаружитьРуки() {
            if (!рукиМодель) {
                console.warn('Модель обнаружения рук еще не загружена.');
                setTimeout(обнаружитьРуки, 100); // Повторная попытка через 100 мс
                return;
            }

            const estimationConfig = { flipHorizontal: true }; // Зеркальное отображение
            const handsPredictions = await рукиМодель.estimateHands(videoElement, estimationConfig);

            canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height); // Очищаем canvas

            // Рисуем обнаруженные объекты
            detectedObjects.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                let label = prediction.class;
                let color = 'yellow'; // По умолчанию желтый

                 if (['knife', 'gun', 'scissors'].includes(label)) {
                    color = 'red';
                    label = `опасный: ${label}`;
                } else if (['apple', 'banana', 'pizza', 'sandwich', 'cake', 'hot dog', 'donut'].includes(label)) {
                    color = 'green';
                    label = `еда: ${label}`;
                }

                canvasContext.strokeStyle = color;
                canvasContext.lineWidth = 2;
                canvasContext.strokeRect(x, y, width, height);
                canvasContext.fillStyle = color;
                canvasContext.font = '16px sans-serif';
                canvasContext.fillText(label, x + 5, y + 20);
            });

            if (handsPredictions.length > 0) {
                рукиPredictions.forEach(prediction => {
                    const landmarks = prediction.landmarks;
                    // Рисуем ограничивающий прямоугольник
                    const минX = Math.min(...landmarks.map(p => p[0] * canvasElement.width));
                    const минY = Math.min(...landmarks.map(p => p[1] * canvasElement.height));
                    const максX = Math.max(...landmarks.map(p => p[0] * canvasElement.width));
                    const максY = Math.max(...landmarks.map(p => p[1] * canvasElement.height));
                    const width = максX - минX;
                    const height = максY - минY;

                    canvasContext.strokeStyle = 'green';
                    canvasContext.lineWidth = 2;
                    canvasContext.strokeRect(минX, минY, width, height);

                    // Get пальцы positions
                     const палецКончики = [
                        landmarks[4],  // Thumb tip
                        landmarks[8],  // Index finger tip
                        landmarks[12], // Middle finger tip
                        landmarks[16], // Ring finger tip
                        landmarks[20]  // Pinky finger tip
                    ];

                    // Check if пальцы are up
                    палецВерх = палецКончики.map(палец => {
                        const палецY = палец[1] * canvasElement.height;
                        const суставY = landmarks[палецКончики.indexOf(палец) * 4 + 2][1] * canvasElement.height; // Get Y of the сустав below the палец
                        return палецY < суставY;
                    });

                    // Check for кулак
                    кулак = палецВерх.every(v => !v);

                    // Gesture recognition logic
                    if (кулак) {
                        кулакПопытки++;
                        if (кулакПопытки >= 2) {
                            isDrawing = true;
                            gestureInfoElement.textContent = "Режим рисования: активирован";
                        }
                    } else {
                        кулакПопытки = 0;
                    }

                     if (isDrawing && палецВерх[1] && !палецВерх[0] && !палецВерх[2] && !палецВерх[3] && !палецВерх[4]) {
                        // Указательный палец поднят, остальные опущены -> рисование
                        const x = landmarks[8][0] * canvasElement.width;
                        const y = landmarks[8][1] * canvasElement.height;
                        if (предыдущаяX === 0 && предыдущаяY === 0) {
                            предыдущаяX = x;
                            предыдущаяY = y;
                        }
                        canvasContext.beginPath();
                        canvasContext.moveTo(предыдущаяX, предыдущаяY);
                        canvasContext.lineTo(x, y);
                        canvasContext.strokeStyle = 'black';
                        canvasContext.lineWidth = 5;
                        canvasContext.lineCap = 'round'; // Make the line ends rounded
                        canvasContext.stroke();
                        предыдущаяX = x;
                        предыдущаяY = y;
                    } else {
                        предыдущаяX = 0;
                        предыдущаяY = 0;
                    }

                    // "OK" gesture recognition (указательный и большой пальцы близко)
                    if (палецВерх[0] && палецВерх[1] && !палецВерх[2] && !палецВерх[3] && !палецВерх[4]) {
                         const кончикБольшогоПальца = landmarks[4];
                         const кончикУказательногоПальца = landmarks[8];
                         const distance = Math.hypot(
                            кончикБольшогоПальца[0] * canvasElement.width - кончикУказательногоПальца[0] * canvasElement.width,
                            кончикБольшогоПальца[1] * canvasElement.height - кончикУказательногоПальца[1] * canvasElement.height
                            );
                        if (distance < 50) { // Adjust this threshold as needed
                            isDrawing = false;
                            canvasContext.clearRect(0, 0, canvasElement.width, canvasElement.height); // Clear canvas
                            gestureInfoElement.textContent = "Рисунок очищен";
                        }
                    }
                });
            }
            requestAnimationFrame(обнаружитьРуки);
        }

        async function обнаружитьЛица() {
            if (!лицоМодель) {
                console.warn("Модель обнаружения лиц еще не загружена");
                setTimeout(обнаружитьЛица, 100);
                return;
            }
            try {
                const detections = await faceapi.detectAllFaces(videoElement, new faceapi.TinyFaceDetectorOptions()).withAgeAndGender().withFaceExpressions();

                detections.forEach(detection => {
                    const box = detection.detection.box;
                    canvasContext.strokeStyle = 'yellow';
                    canvasContext.lineWidth = 2;
                    canvasContext.strokeRect(box.x, box.y, box.width, box.height);

                    const возраст = Math.round(detection.age);
                    const гендер = detection.gender;
                    const выражения = detection.expressions;
                    const доминирующееВыражение = Object.keys(выражения).reduce((a, b) => выражения[a] > выражения[b] ? a : b);

                    canvasContext.fillStyle = 'yellow';
                    canvasContext.font = '14px sans-serif';
                    canvasContext.fillText(
                        `Возраст: ${возраст}, Пол: ${гендер}, Эмоция: ${доминирующееВыражение}`,
                        box.x + 5,
                        box.y - 5
                    );
                });
            } catch (error) {
                 console.error("Ошибка во время обнаружения лиц:", error);
            }
            requestAnimationFrame(обнаружитьЛица);
        }

        // Загружаем модели и запускаем обнаружение
        загрузитьМодели();
    </script>
</body>
</html>
